;------------------------------------------------------------
; Функция преобразования строки в вещественное число
; by ManHunter / PCL
; http://www.manhunter.ru
;
; Параметры:
;   lpStr - указатель на исходную строку в формате ASCIIZ
;   lpResult - указатель на переменную-приемник значения
; На выходе:
;   EAX = 1 - строка успешно преобразована
;   EAX = 0 - строка не может быть преобразована в число
;
; Примечание: переменная-приемник может иметь размер DWORD
; или QWORD, в зависимости от этого должна изменяться и
; функция (см. комментарии в конце кода). По умолчанию
; считается, что переменная имеет размер DWORD
;------------------------------------------------------------
;flt	 db '-15.245e+6',0
;result  dq ?

string2float: ;lpStr db '...',lpResult dq
	mov	ebp, esp
	; Локальные переменные
	;locals
	;  dot	  dd ?	 ; Указатель на дробную часть
	;  exp	  dd ?	 ; Указатель на экспоненту
	;  digit  dd ?	 ; Цифра
	;endl
	pusha
	; Проверка строки на валидность
	mov	[digit],1
	mov	[exp],0
	mov	[dot],0
	mov	esi,[ebp + 04]
	; Минус или плюс может быть только в начале
	cmp	byte [esi],'-'
	je	@f
	cmp	byte [esi],'+'
	jne	.loc_chk_loop
    @@: inc	esi
	; После знака не может быть нуля
	cmp	byte [esi],0
	je	.loc_chk_error
   .loc_chk_loop:
	; В строке должны быть цифр, экспонента и не более одной точки
	lodsb
	or	al,al
	jz	.loc_chk_complete
	cmp	al,'e'
	je	.loc_chk_exp
	cmp	al,'E'
	je	.loc_chk_exp
	cmp	al,'.'
	je	.loc_chk_dot
	cmp	al,'0'
	jb	.loc_chk_error
	cmp	al,'9'
	ja	.loc_chk_error
	jmp	.loc_chk_loop
   .loc_chk_dot:
	; Точка в строке уже есть?
	cmp	[dot],0
	; Строка имеет некорректный формат
	jne	.loc_chk_error
	; Экспонента уже есть?
	cmp	[exp],0
	; Строка имеет некорректный формат
	jne	.loc_chk_error
	; Указатель на дробную часть
	mov	[dot],esi
	jmp	.loc_chk_loop
   .loc_chk_exp:
	; Экспонента уже есть?
	cmp	[exp],0
	; Строка имеет некорректный формат
	jne	.loc_chk_error
	; Указатель на начало экспоненты
	mov	[exp],esi
	; Сразу после экспоненты не может быть нуля
	cmp	byte [esi],0
	je	.loc_chk_error
	; После экспоненты может быть знак
	cmp	byte [esi],'-'
	je	@f
	cmp	byte [esi],'+'
	jne	.loc_chk_loop
   @@:	inc	esi
	; Сразу после минуса не может быть нуля
	cmp	byte [esi],0
	je	.loc_chk_error
	; Проверить следующий символ
	jmp	.loc_chk_loop
   .loc_chk_error:
	; Строка не является числом
	mov	[digit],0
	jmp	.loc_ret
   .loc_chk_complete:
	; Инициализация сопроцессора
	finit
	; Начальное значение числа
	fldz
	; Множитель и делитель
	mov	[digit],10
	fild	dword [digit]
	; Запись значений до запятой
	mov	esi,[ebp + 04]
	; В начале строки минус?
	cmp	byte [esi],'-'
	je	@f
	cmp	byte [esi],'+'
	jne	.loc_before_dot
    @@: inc	esi
	; Преобразование числа до запятой
   .loc_before_dot:
	lodsb
	; Конец строки?
	or	al,al
	jz	.loc_complete
	cmp	al,'.'
	je	.loc_complete_before_dot
	cmp	al,'e'
	je	.loc_exp
	cmp	al,'E'
	je	.loc_exp
	; Очередная цифра
	sub	al,'0'
	movzx	eax,al
	mov	[digit],eax
	; Записать
	fild	dword [digit]
	fxch	st2
	fmul	st0,st1
	fxch	st2
	fadd	st2,st0
	ffree	st0	; Почистить стек
	fincstp
	jmp	.loc_before_dot
	; Преобразование дробной части числа
   .loc_complete_before_dot:
	; Дробная часть есть?
	cmp	[dot],0
	je	.loc_complete_after_dot
	; Экспонента есть?
	cmp	[exp],0
	je	@f
	; Указатель на начало экспоненты
	mov	esi,[exp]
	jmp	.loc_start_after_dot
    @@: ; Иначе перенести указатель на конец строки
	xor	ecx,ecx
	dec	ecx
	xor	eax,eax
	mov	edi,esi
	repne	scasb
	mov	esi,edi
   .loc_start_after_dot:
	std
	dec	esi
	dec	esi
	; Дробная часть
	fldz
	fxch	st1
   .loc_after_dot:
	lodsb
	; Конец дробной части?
	cmp	al,'.'
	je	.loc_complete_after_dot
	; Очередная цифра
	sub	al,'0'
	movzx	eax,al
	mov	[digit],eax
	; Записать
	fild	dword [digit]
	fadd	st2,st0
	fxch	st2
	fdiv	st0,st1
	fxch	st2
	ffree	st0	; Почистить стек
	fincstp
	jmp	.loc_after_dot
   .loc_complete_after_dot:
	; Сбросить флаг направления
	cld
	ffree	st0	; Почистить стек
	fincstp
	; Сложить дробную и целую часть
	fadd	st1,st0
   .loc_exp:
	; Экспонента есть?
	cmp	[exp],0
	je	.loc_complete
	; Получить значение экспоненты
	xor	ecx,ecx
	mov	esi,[exp]
	; В начале строки минус?
	cmp	byte [esi],'-'
	je	@f
	cmp	byte [esi],'+'
	jne	.loc_start_exp
    @@: inc	esi
   .loc_start_exp:
	lodsb
	or	al,al
	jz	.loc_end_exp
	sub	al,'0'
	movzx	eax,al
	imul	ecx,10
	add	ecx,eax
	jmp	.loc_start_exp
   .loc_end_exp:
	or	ecx,ecx
	jz	.loc_complete
	ffree	st0	; Почистить стек
	fincstp
	mov	[digit],10
	fild	dword [digit]
	; Делить или умножать?
	mov	esi,[exp]
	cmp	byte [esi],'-'
	je	.loc_exp_divide
   .loc_exp_multiple:
	fmul	st1,st0
	loop	.loc_exp_multiple
	jmp	.loc_complete
   .loc_exp_divide:
	fdiv	st1,st0
	loop	.loc_exp_divide
   .loc_complete:
	ffree	st0	; Почистить стек
	fincstp
	; В начале строки минус?
	mov	esi,[ebp + 04]
	cmp	byte [esi],'-'
	jne	@f
	; Изменить знак числа
	fchs
    @@: ; Записать значение в ячейку памяти
	mov	eax,[ebp + 08]
	; Если требуется повышенная точность, то приемник
	; должен иметь размер QWORD, а следующую команду
	; надо заменить на fstp qword [eax]
	fstp	dword [eax]
	; Успешное преобразование
	mov	[digit],1
   .loc_ret:
	popa
	; Результат преобразования
	mov	eax,[digit]
ret 4*2


; strings lib
; for asciiz strings
; ds:esi - source string
; es:edi - destination string

; string length
;  IN:	esi - string
;  OUT: ecx and eax - string length
strlen:
	push	edi esi ecx

	mov	edi, esi

	xor	eax, eax
	mov	ecx, eax
	not	ecx
	cld
	repnz	scasb
	not	ecx	; neg ecx :)
	dec	ecx	;
	mov	eax, ecx

	pop	ecx esi edi
	ret

; copy one string to another
;  IN:	ds:esi - source
;	es:edi - destination
;  OUT: -
strcopy:
	push	ecx
	push	esi
	push	edi

	call	strlen
	inc	ecx	; copy 0
	cld
	rep	movsb

	pop	edi
	pop	esi
	pop	ecx
	ret


; to uppercase - for ascii table only!
;  IN:	ds:esi - source string
;	es:edi - destination (may be = source)
;  OUT: -
strtoupper:
	push	eax
	push	ecx
	push	edi
	push	esi

	xor	eax, eax
	mov	ecx, eax
	not	ecx
	cld
   .l1: lodsb
	or	al, al
	jz	.exit
	cmp	al, 'a'
	jb	.l2
	cmp	al, 'z'
	ja	.l2
	sub	al, ('a'-'A')
   .l2: stosb
	loop	.l1
   .exit:
	pop	esi
	pop	edi
	pop	ecx
	pop	eax
	ret

; to lowercase - for ascii table only!
;  IN:	ds:esi - source string
;	es:edi - destination (may be = source)
;  OUT: -
strtolower:
	push	eax
	push	ecx
	push	edi
	push	esi

	xor	eax, eax
	mov	ecx, eax
	not	ecx
	cld
   .l1: lodsb
	or	al, al
	jz	.exit
	cmp	al, 'A'
	jb	.l2
	cmp	al, 'Z'
	ja	.l2
	add	al, ('a'-'A')
   .l2: stosb
	loop	.l1
   .exit:
	pop	esi
	pop	edi
	pop	ecx
	pop	eax
	ret

; compares two strings (case sensitive)
;  IN:	ds:esi - string1
;	es:edi - string2
;  OUT: flags for j-condition (ja,je,...)
_strcmp:
	push	eax
	push	edi
	push	esi

	cld
   .l1: lodsb
	scasb
	jne	.exit
	or	al, al
	jnz	.l1
   .exit:
	pop	esi
	pop	edi
	pop	eax
	ret

; searches one string for another
;  IN:	ds:esi - string to look in
;	es:edi - string to search for
;  OUT: edx - position (-1 if not found)
strpos:
	push	esi
	push	edi
	push	eax
	push	ebx
	push	ecx

	call	strlen
	mov	eax, ecx	; eax = str1.Length;
	xchg	esi, edi
	call	strlen
	cmp	eax, ecx
	jb	.notfound	; exit if str2.Length > str1.Length;

	mov	ebx, ecx	; ebx = str2.Length
	sub	eax, ebx	; last possible index
	xchg	esi, edi
	xor	edx, edx

   .l1: mov	cl, [ebx+esi]		; save byte
	mov	byte[ebx+esi], 0	; end of string
	call   _strcmp			; compare
	mov	[ebx+esi], cl		; restore byte
	je	.exit
	inc	esi
	inc	edx
	cmp	eax, edx	; end of str1
	jne	.l1

   .notfound:
	xor	edx, edx
	dec	edx		; -1 - not found

   .exit:
	pop	ecx
	pop	ebx
	pop	eax
	pop	edi
	pop	esi
	ret



;-----------------------------------------------------
; Функция замены подстроки в строке
;-----------------------------------------------------
; lpSrc - указатель на исходную строку
; lpDst - указатель на буфер для полученной строки
; lpPattern - указатель на заменяемую подстроку
; lpReplace - указатель на строку для замены
; dNum - количество замен (0 - заменить все)
;-----------------------------------------------------
;	       4	    8		     12 	      16	   20
str_replace: ; lpSrc:DWORD, lpPattern:DWORD, lpReplace:DWORD, lpDst:DWORD, dNum:DWORD
	mov	ebp, esp
	pusha
	mov	edx, dword[ebp + 16]			 ; Указатель на буфер-приемник
	xor	ebx, ebx			 ; Счетчик замен
	; Исходная строка не пустая?
	mov	ecx, dword[ebp + 04]
	cmp	byte [ecx],0
	jz     .loc_ret
	; Заменяемая строка не пустая?
	mov	eax, dword[ebp + 08]
	cmp	byte [eax],0
	jz     .loc_copy_all
   .loc_scan:
	mov	esi, ecx
	mov	edi, dword[ebp + 08]
	; Исходная строка закончилась?
	cmp	byte [esi],0
	je     .loc_end_replace
    @@: ; Строки совпали с паттерном?
	cmp	byte [edi],0
	je     .loc_move_replace
	; Символ совпадает с
	lodsb
	; Заменять все вхождения?
	cmp	dword[ebp + 20],0
	je     .loc_skip_counter
	; Уже заменили нужное количество?
	cmp	ebx, dword[ebp + 20]
	je     .loc_move_one_char
   .loc_skip_counter:
	cmp	al, byte [edi]
	jne    .loc_move_one_char
	inc	edi
	jmp	@b
   .loc_move_replace:
	; Увеличить счетчик замен
	inc	ebx
	mov	ecx,esi
	; Записать заменяющую строку
	mov	esi, dword[ebp + 12]
	mov	edi,edx
    @@: lodsb
	or	al,al
	jz     .loc_scan
	stosb
	inc	edx
	jmp	@b
   .loc_move_one_char:
	; Скопировать один символ
	mov	al,byte [ecx]
	mov	byte [edx],al
	inc	edx
	inc	ecx
	jmp    .loc_scan
   .loc_end_replace:
	; Записать финальный 0 в строку
	mov	byte [edx],0
	jmp    .loc_ret
   .loc_copy_all:
	; Просто скопировать исходную строку
	mov	esi, dword[ebp + 04]
	mov	edi, dword[ebp + 16]
    @@: lodsb
	stosb
	or	al,al
	jnz	@b
   .loc_ret:
	popa
ret 4*5












ALIGN 4
HEX2STR_32BIT:	  ; EAX->, ^EDI<-
		mov	ecx,7
 .1:		mov	edx,eax
		shr	eax,4
		and	edx,0xF
		cmp	edx,0xA
		jae    .2
		add	edx,'0'
		jmp    .3
 .2:		add	edx,'A' - 0xA
 .3:		mov	byte[edi + ecx],dl
		dec	ecx
		jns    .1
		mov	byte[edi + 8],0
ret


ALIGN 4
HEX2STR_128BIT:    ; ^ESI->, ^EDI<-
		PUSHAD
		XOR	ECX, ECX
		;
	    @@: INC	ECX
		CMP	ECX, 16
		JA     .END
		LODSB
		PUSH	ECX
		MOV	DL,  AL
		MOV	ECX, 0x02
	   .L1: ROL	DL,  0x04
		MOV	EAX, 0x300F
		AND	AL,  DL
		AAA
		AAD	0x11
		STOSB
		LOOP   .L1
		POP	ECX
		JMP	@B
	       .END:
		XOR	EAX, EAX
		STOSB
		POPAD
RET